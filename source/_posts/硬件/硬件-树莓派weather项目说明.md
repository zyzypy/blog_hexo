---
title: 树莓派weather项目说明
comments: true
toc: true
date: 2018-05-13 14:53:42
updated: 2018-07-04 10:33:42
tags:
- 树莓派
- 天气
- pm25
- 传感器
- 攀藤
- 项目
- 硬件
- 驱动
categories:
- 硬件
banner: DSC1207.JPG
---
## 背景
粉尘传感器用途广泛，比如空气净化器，比如工厂里为了工人健康设置的空气监测器。时下备受关注的pm2.5污染问题。了解粉尘监测系统具体原理。原来此类项目依赖C语言和单片机，现在树莓派让高级语言开发者也能控制硬件，享受乐趣和产生更多创意。

## 目的
熟悉树莓派基本操作，熟悉linux环境
熟练掌握python编程语言
驱动传感器，理解和设计采集算法

## 具体需求
1. 基于树莓派、粉尘传感器、温度传感器
2. 驱动传感器采集数据。
3. 将数据展示出来。

## 软件技术栈选择
- 编程语言： python。 选择原因： 
	语法简洁易懂的编程语言，树莓派系统已自带。  
	类库调用丰富，可支持树莓派的GPIO和串口，用来驱动传感器。
- 后台web框架： flask。  
	种基于python的轻量web框架，负责整合前后端
- 前端界面框架： material。  
	谷歌公司设计的一种前端框架，类似bootstrap，负责整体界面布局
- 图表：high-chart 。  
	一个流行的js图表插件，负责界面中图表，展示传感器的数据
后面讲详述每一个技术在代码中的职责

## 硬件选择
- 树莓派3b
	为教育目的设计的开源硬件。选择原因：
	1. 性能强大远高于单片机，搭载linux系统，可以办到更多事情。
	2. 搭载GIPO让人们可以驱动硬件，让高级语言使用者（java，python）也能通过GPIO驱动硬件
- 攀藤G5s（pms5003）传感器
	1. 经上网查询得知，市面所有激光检测仪、空气净化器中使用的都是攀藤公司的产品。攀藤公司专业生产出售粉尘传感器，价格低于国外，精度质量又高于红外原理的传感器，因此在市场中占据主流地位。于是随大流选择攀藤传感器，说明书和参考资料都较为丰富。
	2. 具体型号选择：攀藤公司下有数种粉尘传感器。区别主要是体积大小、是否集成温度功能、是否集成甲醛功能。因为积小的贵，甲醛传感器单买较贵、有网友反映集成的温度功能不准，最终选择体积较大、粉尘甲醛二合一的g5s型号。
-  DHT22温湿度传感器
	1. 一款流行的温湿度传感器，相比dht11精度较高，精确到0.1度

## 整体流程说明
1. 传感器连接树莓派
粉尘传感器-》排线转ttl-》电源vcc、地线gnd、数据出tx分别接树莓派GPIO的vcc、gnd、rx （对应针查看树莓派gpio图）
温度传感器-》电源vcc、地线gnd、数据分别接树莓派GPIO的vcc、gnd、gpio
2. 用python书写了两个传感器的驱动，用flask书写web服务，将收集到的数据返回到前端
3. 启动树莓派上写好的web服务
4. 浏览器访问树莓派ip看到结果页面

## 硬件连接说明
- 粉尘传感器=》树莓派  
	1. 先准备转接板。传感器是1.25mm的排针，要先通过转接板转成2.25mm的ttl才能用来开发测试。
	2. 分析传感器引脚和树莓派引脚。粉尘传感器引脚官方说明书如图
	![](pms5003_1.png)
	树莓派引脚示意如图
	![](硬件连接0.jpg)
	分析和参考网上得知，传感器出来的引脚除去reset、预留引脚、休眠模式开关、数据接收引脚，只有三个引脚有用：电源正、地线电源负、数据出。参考树莓派引脚，与之一一对应连接。
	3. 具体连接。传感器vcc-树莓派5v电源（物理引脚编码2）；传感器gnd-树莓派gnd（6）；传感器tx-树莓派rx（10）。如图
	![](硬件连接1.jpg)
- 温度传感器=》树莓派
	1. 温度传感器三个引脚：电源正、电源负、数据。
	2. 具体连接： 传感器vcc-树莓派3.3v电源（1）；传感器gnd-树莓派gnd（9）；传感器数据-树莓派gpio（7）。如图
	![](硬件连接2.jpg)
- 外设
	键鼠，显示器

## 代码设计与测试与运行
### 粉尘驱动
0. 准备工作
树莓派终端命令行`sudo raspi-config` 》interface》serial 打开串口
硬件连接好。
终端输入命令`python -m serial.tools.list_ports`查看可用串口,结果/dev/AMA0

1. 实例化ser对象 并试图读取数据
第一次尝试：
``` 
import serial
ser=serial.Serial("/dev/AMA0", 9600)
ser.read(1)
```
程序ser实例化成功，read接收一个字节时没有反应，几十秒后报超时错误。  
第二次尝试：
如果传感器ttl接串口转usb转接板，转接板插树莓派usb口， 查看可用串口发现/dev/USB1，带入到代码中 `ser=serial.Serial("/dev/USB1", 9600) ser.read(1)`,发现有数据。
第三次尝试：
查询资料得知树莓派串口被蓝牙功能占用，第一次没数据是因为读的就不是传感器返回的数据。按照网上的设置禁用蓝牙并把AMA0映射到gpio尝试未成功。gpio上的串口未软件虚拟串口，可能无法正常使用，设备名为/dev/ttyS0，带入到代码中测试成功
```
ser=serial.Serial("/dev/AMA0", 9600)
ser.read(1)
```
结果类似\x3d之类的十六进制字节数据，说明成功获得传感器传入的二进制byte数据。

2. 数据解析
读取数据成功后开始分析和处理。  
粉尘传感器说明书如下
![](粉尘说明书2.png)
![](粉尘说明书3.png)
	1. 分析和设计：传感器不断返回数据，用python代码实例化串口ser并不断read()接收数据，为了判断数据开始，传感器提供了两个标识开始的字节。如果接收到的数据恰好等于这两个固定值，则开始接收完整一帧的数据，再向后接收30个字节数据。接收到的字节每2个一组，转换成十进制就是结果。概括来说就是：2字节开始标识 + 2字节帧长度 + 26字节数据（13组数据）+ 2字节校验 = 共32字节。
	2. 检测开始标识：不断read()字节，如果检测到读取字节等于起始符1并且下一个字节又等于起始符2，那么往后再取30字节，作为完整的一帧。代码如下：
	```
		ser = Serial(/dev/ttyS0)
		bytes = b''		# 完整的一帧
		while True：
			temp_byte = ser.read(1)
			if temp_byte == 0x42:	# 起始符1
				temp_byte2 = ser.read(1)
				if temp_byte2 == 0x4d:	# 起始符2
					temp_byte3 = ser.read(30)	# 往后取数据
					bytes = 0x42 + 0x4d + temp_byte3	# 拼起来
	```
	3. 数据帧每两个字节分一组，转换成十进制，输出到命令行：在测试中发现，起始位，帧长度固定不变，所以截去。校验位因为传感器芯片已经预先处理舍弃掉不合格的数据，所以接收到的数据校验位一定校验成功，所以也舍去。只留中间26个字节的数据。代码如下：
	```
		data_bytes = bytes[4: 30]	# 第5到第30字节
		data_arr = byteattr(data_bytes)	# 转换成自己组
		pm25 = int(data_arr(2)*256+data_arr(3)	# pm2.5对照说明书在数据字节的第3、4字节,高位字节乘2的八次方，最后结果转换为10进制
		print(pm25)
	```
	4. 完成代码
	实际编码过程中遇到的问题有serial实例化失败，数据读取不正确数字很大或负数，经过不断测试发现数组下标取错了。最终完整代码如下：  
	![](代码粉尘1.png)
	结果打印到终端：
	![](代码粉尘2.png)

### 温度驱动
1. 实例化接口。温度传感器接树莓派物理引脚7，对应BCM模式的18
```
from RPi import GPIO
channel = 18    # BCM4 pin7
GPIO.setmod(BCM)
```
2. 设计数据采集。
dht22官方说明书如下  
![](dht22说明书.png)
试验发现，dht22传感器并不想上面的粉尘传感器返回数值数据转换成十进制即可。而是每次输出根据高低电平输出一段0和1，类似‘1111100000000110’。说明书上的高低电平持续时间和规律，就是信号开始的依据，就像粉尘传感器的起始位数据。数据开始传输后根据高电平持续时间26us和70us时间内k的个数不同判断表示的是1还是0，循环40次，得出40bit数据。这点跟粉尘传感器返回字节单位不同。伪代码如下：
```
data = ''
while j < 40:   # 一帧40bit
    k = 0	
    while GPIO.input(channel) == GPIO.LOW:		# 低电平为传感器开始信号
        continue
    # 根据1的个数（即高电平的时间来判断0 low还是1 high）
    while GPIO.input(channel) == GPIO.HIGH:
        k = k + 1
        if k > 100:				# 低电平后长时间的高电平，标识开始传输数据
            break
    print(j, k)
    if k < 16:					# 根据实际跑出的数据，以k=16作为区分返回数据表示1还是0的分割点
        data.append(0)
    else:
        data.append(1)
    j += 1
```
3. 数据处理。40bit共5字节，湿度整数+湿度小数+温度整数+温度小数+校验位，所以01构成的字符串先转换为字节，然后截取字节，最后字节转换成十进制。代码如下：
```
humidity_integer = int(byte(data[0:8]) )   # 湿度整数
humidity_decimal = int(byte(data[8:16] )  # 湿度小数，默认0
temperature_integer = int(byte(data[16:24])  # 温度
temperature_decimal = int(byte(data[24:32])	# 温度小数
print(temperature_integer, humidity_integer)
```
4. 完整代码
![](代码dht22.png)

### web框架、前端框架、js图表插件
1. 前端框架material。相当于骨架，定义了几行*几列的网页大体框架![](web0.png)
2. js方法setInterval()定时每5s请求后端
3. flask框架将传感器驱动封装为接口方法。被前端请求后采集传感器数据，存入session或sqlite数据库供同一时间的其它请求读取，因为多个请求实例化串口会导致报错。
4. 返回的变量渲染到前端html，填入图表插件供展示。flask连接了前后端并提供web服务。
5. highchart接收数据，展示出图表
6. 主要文件app.py 和index.html的部分代码截图
![](web1.png)
![](web2.png)

## 部署和运行
1. pc和树莓派连接到同一局域网下
2. 查看路由获取树莓派ip
3. 通过sftp工具和树莓派默认密码登陆到树莓派
4. 切换到root用户
5. 把代码传到树莓派下
6. cd 到项目目录下 python3 app.py运行flask的web服务
7. 同一局域网的浏览器访问树莓派ip看web结果网页

## 项目最终硬件连接和网页展示
![](效果图1.jpg)
![](效果图2.png)

## 来自对方的礼物🎁😀
![](DSC1207.JPG)

## license
已有乙方使用 🚫禁止转载 